// Copyright 2021 Axiom-Team
//
// This file is part of Substrate-Libre-Currency.
//
// Substrate-Libre-Currency is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, version 3 of the License.
//
// Substrate-Libre-Currency is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with Substrate-Libre-Currency. If not, see <https://www.gnu.org/licenses/>.

#[macro_export]
macro_rules! pallets_config {
	{$($custom:tt)*} => {
		$($custom)*

		// SYSTEM //

		parameter_types! {
			pub const Version: RuntimeVersion = VERSION;
		}

        impl frame_system::Config for Runtime {
            /// The basic call filter to use in dispatchable.
            type BaseCallFilter = frame_support::traits::Everything;
            /// Block & extrinsics weights: base values and limits.
            type BlockWeights = BlockWeights;
            /// The maximum length of a block (in bytes).
            type BlockLength = BlockLength;
            /// The identifier used to distinguish between accounts.
            type AccountId = AccountId;
            /// The aggregated dispatch type that is available for extrinsics.
            type Call = Call;
            /// The lookup mechanism to get account ID from whatever is passed in dispatchers.
            type Lookup = AccountIdLookup<AccountId, ()>;
            /// The index type for storing how many extrinsics an account has signed.
            type Index = Index;
            /// The index type for blocks.
            type BlockNumber = BlockNumber;
            /// The type for hashing blocks and tries.
            type Hash = Hash;
            /// The hashing algorithm used.
            type Hashing = BlakeTwo256;
            /// The header type.
            type Header = generic::Header<BlockNumber, BlakeTwo256>;
            /// The ubiquitous event type.
            type Event = Event;
            /// The ubiquitous origin type.
            type Origin = Origin;
            /// Maximum number of block number to block hash mappings to keep (oldest pruned first).
            type BlockHashCount = BlockHashCount;
            /// The weight of database operations that the runtime can invoke.
            type DbWeight = RocksDbWeight;
            /// Version of the runtime.
            type Version = Version;
            /// Converts a module to the index of the module in `construct_runtime!`.
            ///
            /// This type is being generated by `construct_runtime!`.
            type PalletInfo = PalletInfo;
            /// What to do if a new account is created.
            type OnNewAccount = ();
            /// What to do if an account is fully reaped from the system.
            type OnKilledAccount = ();
            /// The data to be stored in an account.
            type AccountData = pallet_balances::AccountData<Balance>;
            /// Weight information for the extrinsics of this pallet.
            type SystemWeightInfo = ();
            /// This is used as an identifier of the chain. 42 is the generic substrate prefix.
            type SS58Prefix = SS58Prefix;
            /// The set code logic, just the default since we're not a parachain.
            type OnSetCode = ();
			type MaxConsumers = frame_support::traits::ConstU32<16>;
        }

		// SCHEDULER //

		parameter_types! {
			pub MaximumSchedulerWeight: Weight = Perbill::from_percent(80) *
				BlockWeights::get().max_block;
			pub const MaxScheduledPerBlock: u32 = 50;
		}
		/// Used the compare the privilege of an origin inside the scheduler.
		pub struct OriginPrivilegeCmp;
		impl frame_support::traits::PrivilegeCmp<OriginCaller> for OriginPrivilegeCmp {
			fn cmp_privilege(left: &OriginCaller, right: &OriginCaller) -> Option<core::cmp::Ordering> {
				if left == right {
					Some(core::cmp::Ordering::Equal)
				} else {
					None
				}
			}
		}
		impl pallet_scheduler::Config for Runtime {
			type Event = Event;
			type Origin = Origin;
			type PalletsOrigin = OriginCaller;
			type Call = Call;
			type MaximumWeight = MaximumSchedulerWeight;
			type ScheduleOrigin = frame_system::EnsureSigned<AccountId>;
			type OriginPrivilegeCmp = OriginPrivilegeCmp;
			type MaxScheduledPerBlock = MaxScheduledPerBlock;
			type WeightInfo = pallet_scheduler::weights::SubstrateWeight<Runtime>;
			type PreimageProvider = ();
			type NoPreimagePostponement = ();
		}

		// MONEY //

		impl pallet_balances::Config for Runtime {
            type MaxLocks = MaxLocks;
            type MaxReserves = ();
            type ReserveIdentifier = [u8; 8];
            /// The type for recording an account's balance.
            type Balance = Balance;
            /// The ubiquitous event type.
            type Event = Event;
            type DustRemoval = ();
            type ExistentialDeposit = ExistentialDeposit;
            type AccountStore = System;
            type WeightInfo = pallet_balances::weights::SubstrateWeight<Runtime>;
        }

        impl pallet_transaction_payment::Config for Runtime {
            type OnChargeTransaction = CurrencyAdapter<Balances, ()>;
            type TransactionByteFee = TransactionByteFee;
			type OperationalFeeMultiplier = frame_support::traits::ConstU8<5>;
            type WeightToFee = common_runtime::fees::WeightToFeeImpl<Balance>;
            type FeeMultiplierUpdate = ();
        }

		// CONSENSUS  //

        impl pallet_grandpa::Config for Runtime {
            type Event = Event;
            type Call = Call;

            type KeyOwnerProofSystem = ();

            type KeyOwnerProof =
                <Self::KeyOwnerProofSystem as KeyOwnerProofSystem<(KeyTypeId, GrandpaId)>>::Proof;

            type KeyOwnerIdentification = <Self::KeyOwnerProofSystem as KeyOwnerProofSystem<(
                KeyTypeId,
                GrandpaId,
            )>>::IdentificationTuple;

            type HandleEquivocation = ();

            type WeightInfo = ();

			type MaxAuthorities = MaxAuthorities;
        }

		// UTILITY //

		impl pallet_utility::Config for Runtime {
			type Event = Event;
			type Call = Call;
			type PalletsOrigin = OriginCaller;
			type WeightInfo = pallet_utility::weights::SubstrateWeight<Self>;
		}

		// MONEY CREATION //

        impl pallet_universal_dividend::Config for Runtime {
            type Currency = pallet_balances::Pallet<Runtime>;
            type Event = Event;
            type MembersCount = common_runtime::providers::UdAccountsProvider<Runtime>;
            type MembersIds = common_runtime::providers::UdAccountsProvider<Runtime>;
            type SquareMoneyGrowthRate = SquareMoneyGrowthRate;
            type UdCreationPeriod = UdCreationPeriod;
			type UdFirstReeval = UdFirstReeval;
            type UdReevalPeriod = UdReevalPeriod;
            type UdReevalPeriodInBlocks = UdReevalPeriodInBlocks;
			type UnitsPerUd = frame_support::traits::ConstU64<1_000>;
        }

        impl pallet_ud_accounts_storage::Config for Runtime {}

		// WEB OF TRUST //

		impl pallet_identity::Config for Runtime {
            type ConfirmPeriod = ConfirmPeriod;
            type Event = Event;
            type AddRightOrigin = EnsureRoot<Self::AccountId>;
            type DelRightOrigin = EnsureRoot<Self::AccountId>;
            type EnsureIdtyCallAllowed = EnsureIdtyCallAllowedImpl<Runtime, StrongCert>;
			type IdtyCreationPeriod = IdtyCreationPeriod;
			type IdtyDataProvider = ();
            type IdtyData = ();
            type IdtyNameValidator = IdtyNameValidatorImpl;
            type IdtyIndex = IdtyIndex;
            type IdtyValidationOrigin = EnsureRoot<Self::AccountId>;
            type IdtyRight = IdtyRight;
            type OnIdtyChange = OnIdtyChangeHandler<Runtime>;
            type OnRightKeyChange = OnRightKeyChangeHandler<Runtime>;
            type MaxNoRightPeriod = MaxNoRightPeriod;
			type Membership = Membership;
        }

		impl pallet_membership::Config<frame_support::instances::Instance1> for Runtime {
			type IsIdtyAllowedToClaimMembership = ();
			type IsIdtyAllowedToRenewMembership = ();
			type IsIdtyAllowedToRequestMembership = ();
			type IsOriginAllowedToUseIdty = Identity;
			type Event = Event;
			type ExternalizeMembershipStorage = frame_support::traits::ConstBool<false>;
			type IdtyId = IdtyIndex;
			type OnEvent = Identity;
			type MembershipExternalStorage = ();
			type MembershipPeriod = MembershipPeriod;
			type PendingMembershipPeriod = PendingMembershipPeriod;
			type RenewablePeriod = RenewablePeriod;
			type RevocationPeriod = frame_support::traits::ConstU32<0>;
		}

        impl pallet_certification::Config<frame_support::instances::Instance1> for Runtime {
            type AddCertOrigin = AddStrongCertOrigin<Runtime>;
            type CertPeriod = CertPeriod;
            type DelCertOrigin = DelStrongCertOrigin<Runtime>;
            type Event = Event;
            type IdtyIndex = IdtyIndex;
            type MaxByIssuer = MaxByIssuer;
            type OnNewcert =
                OnNewStrongCertHandler<FirstIssuableOn, Runtime, StrongCert, MIN_STRONG_CERT_FOR_UD, MIN_STRONG_CERT_FOR_STRONG_CERT>;
            type OnRemovedCert = OnRemovedStrongCertHandler<Runtime, MIN_STRONG_CERT_FOR_UD>;
            type CertRenewablePeriod = StrongCertRenewablePeriod;
            type ValidityPeriod = ValidityPeriod;
        }

		// MUNTISIG //

		impl pallet_multisig::Config for Runtime {
			type Event = Event;
			type Call = Call;
			type Currency = Balances;
			type DepositBase = DepositBase;
			type DepositFactor = DepositFactor;
			type MaxSignatories = MaxSignatories;
			type WeightInfo = pallet_multisig::weights::SubstrateWeight<Self>;
		}
	};
}
